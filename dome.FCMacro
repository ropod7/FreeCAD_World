#!/usr/bin/env python3
# -*- coding: utf-8 -*-

###############################################################################
#         ____   _____  __   _______ __  _____    _
#        /  __\ /  _  \|  \_| |  ___|  |/ ____\  |_|
#       |  |___|  |_|  |  _   |  |_ |  |  \_,-,   _
#        \____/ \_____/|_| \__|__|-'|__|\___  |  |_|
#                                           '-'
###############################################################################

# Root object params (mm):
DETAILS   = int(16)  # Detalization in edges of polygon
OR     = float(4200) # Outside R of polygon and carriage on X axis
H1     = float(1500) # Height of 1st 'floor' & carriage on Z (or 0)
LONG   = float(0) # Extension & carriage on Y axis (or 0)
THORUS = dict( # Proportionally expanded (OR becomes IR or both False is DOME)
 CORNER = bool(True), # Inner side of thorus. Outside R of dome becomes inside R
 DISC   = bool(True)  # Outer side of thorus. OR = OR*3
) # template of SpreadSheet system of object:
ROWS    = int(DETAILS/4) # Number of rows revolving around Y axis (max: DETAILS/4)
COLS    = int(DETAILS/4)   # Number of cols revolving around Z axis (max: DETAILS)

# Material (mm):
BAR = tuple((50, 200))  # (Width, Height of wooden bar, pipe etc.)

# Compound options:
EXTEND   = bool(True)   # Root as open contour system (fill up long ext, cols etc.)
COMPOUND = bool(False)  # Simple compounded object (if LONG: COLS <= DETAILS/2)

# Movement (mm):
ROTATE = dict( # Rotate compounded or extended object
 DO       = bool(False),     # Do rotate or not
 ANGLE  =  float(180),      # Angle to rotate object
 CENTER = tuple((0, 0, 0)), # Center to rotate object (x, y, z)
 AXIS   = tuple((0, 0, 1)),  # Rotation axis (around x, around y, around z)
 COPY     = bool(True)      # Copy object to rotate
)
MOVE = dict( # Move compounded or extended object
 DO       = bool(False),    # Do move or not
 VECTOR = tuple((10000, 10000, 1000)), # Vector to move object (x, y, z)
 COPY     = bool(True)     # Copy object to move
)

# Extra options:
WIREFRAME = bool(False)      # To reproduce or hide wireframe
ROOT      = bool(True)       # To show just wireframe if reproduced
CLEANUP   = bool(True)       # Clean up document before build [True] or False
PRINT3D  = tuple((190, 190)) # Scale object to 3D printer bed (mm)

"""

       In front of you a machine tool for the production of any FreeCAD
      Macros of any complexity with increased accuracy of calculation of
            target objects of polygonal and orthogonal geometry.
     In current stage it works as calc for practical designs of buildings
  and for overall development of kids, students, individuals and households.

"""

###################################################################################
#######################################################################клинопись###
## top view                                   _ /                                ##
##                                  ^     _ /                                    ##
##                DOME              | _ /             CORNER                     ##             DISC
##     <-                        _  |                                    ->      ##
##  y torsion     -----------,      | y axis                         y torsion   ##
##  |                 B   _ /*| B/2 |                                |           ##
##  |                 _ /******|    |                                |           ##
##  |        OR   _ /****** A **| <---[ base of isosceles triangle ] |           ##
##  |         _ /****************|  | [  and base of construction  ] |           ##
##  |     _ /*********************| |                                |           ##
##  |  _/***** B ******************|| 90°      OR*2 on x axis        |           ##
## 0|------------------------------>|------------------------------->|           ##
##  z [ left ] torsion for DOME and THORUS at x,y: [ 0 mm ]                      ##
## _____________________________________________________________________________ ##
##                                                                               ##
##       B = 360°/DETAILS          A + B/2 = 90°        A = (180° - B)/2         ##
###################################################################################
###################################################################################

###################################################################################
#
#        _   _    ____    ____  _____   _____
#       | \_/ |  |  _ \  /  __\|  _  \ /  _  \
#       |      \ | |_\ \|  |___| |_/ /|  |_|  |       [ logic ]:
#       |_|\/\__||_| |__|\____/|_| \__\\_____/
#
#
###################################################################################

assert not DETAILS % 4 and DETAILS, "DETAILS not in range, or empty (must be divisible by 4)"
assert OR,                          "Empty Radius definition"
assert BAR[0] and BAR[1],           "Empty cell[/s] in BAR definition"
assert OR > BAR[1] * 5,             "Check out BAR definition (OR TOO LOW RADIUS)"
assert BAR[0] < BAR[1],             "Wooden Bar width must be lower than high side"
h =  BAR[1] + BAR[0]/2
assert H1 >= h or not H1,           "H1 must be higher than %smm (wooden bar height+width/2)" % h

import os, sys
import math
from collections.abc import MutableMapping
from PySide import QtCore

# BEGIN: Trigonometrical Common Geometry

class Trigon(object):
    def __init__(self, r, d):
        assert isinstance(r, float), \
            "TypeError: r (OR) must be float"
        assert isinstance(d, int) and not d % 4 and d > 3, \
            "d (DETAILS) not in range or float ( must be: int(d) / 4 = 0 )"
        self.OR = r
        self.CIRCLE = 360
        self.HALF_CIRCLE = self.CIRCLE / 2.0
        self.DETAILS = d
        self.DETAIL_B = self.CIRCLE / d
        self.POLY_QUARTER = int(d / 4)
        self.DETAIL_A = (self.HALF_CIRCLE-self.DETAIL_B) / 2.0
        self.__base_ = self.isoscelesBase(r)

    def cos(self, c):
        return math.cos(math.radians(c))

    def sin(self, c):
        return math.sin(math.radians(c))

    def tan(self, c):
        return math.tan(math.radians(c))

    def rightCathetusB_ByA(self, c, A):
        return c * self.cos(A)

    def rightCathetusA_ByA(self, c, A):
        return c * self.sin(A)

    def rightCathetusA_ByBA(self, b, A):
        return b * self.tan(A)

    def rightHypothenuseByB(self, a, B):
        return a / self.cos(B)

    def rightHypothenuse(self, cathetus):
        return self.rightHypothenuseByB(cathetus, 90.0-self.DETAIL_A)

    def isoscelesSide(self, b, B):
        return b / (2 * self.sin(B/2.0))

    def isoscelesBase(self, Or):
        return Or * 2 * (self.cos((self.HALF_CIRCLE-self.DETAIL_B)/2.0))

    @property
    def base(self):
        return self.__base_

class TwoPoints(Trigon):
    """

        The whole system revolves around these polygonal points.
        (the number of points to identify is: int( DETAILS/4/2 ))

    """
    _root_ = str('dome')

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.POINTS = []

    def polyPoints(self, Or):
        def cathetus(func, side, a): return side * func(a)
        x = y = 0
        a = self.DETAIL_A
        base = self.isoscelesBase(Or)
        p_n = int(self.POLY_QUARTER / 2)
        points = [[Or, y]]
        for i in range(p_n):
            x += cathetus(self.cos, base, a)
            y += cathetus(self.sin, base, a)
            """
                      extra solution for corner to find proportions
                              at Y axis on higher hPoly wf:
                (
                System-wide single deviation is Y == 0.01mm if 0 on X & Y
                )
            """
            y = 0.01 if not y and not x else y

            points.extend([ [Or - x, y] ])
            a -= self.DETAIL_B
        p = points[:-1] if not self.POLY_QUARTER % 2 else points
        """Other side of points list is sequence of reversed points"""
        points.extend([[pp[1], pp[0]] for pp in reversed(p)])
        return points

class ThorusPoints(TwoPoints):
    """
    Additional proportionaly alongated point system to extend poly points
      into their proper positions in case of toroidal building geometry.
    """
    _roots_ = [TwoPoints._root_, str('corner'), str('disc'), str('thorus')]

    def __init__(self, tp, r, *args, **kwargs):
        """Receives type, OR, DETAILS, LONG and H1 definitions"""
        super().__init__(r, *args, **kwargs)
        x = r*2 if tp in __class__._roots_[1:] else 0
        self.ZERO_X =  x        # To measure corners on X carriage
        self.ZERO_Y =  0        # To measure extensions on Y carriage
        self.ZERO_Z =  0        # To lift all types of geometry
        self.pointSystem = tp

    def __fixedXYRoots(self, x, y):
        """
        First couple of root X and Y points in case of Y > 0, to find
        complete proportions of toroidal trigonometry in case of:

            DETAILS / 4 % 4 == 0.
        """
        root_x = self.POINTS[0][1][0]
        root_y = self.POINTS[0][1][1]
        expr = self.pointSystem is __class__._roots_[1]
        root_x = root_x if expr else root_x*2 - (root_x - x)
        root_y = root_y if expr else root_y*2 - (root_y - y)
        return root_x, root_y

    def __fixedZeroYXRoot(self, x):
        expr = self.pointSystem in __class__._roots_[-2:]
        return x*2 if expr else 0

    def _pntBtmMnr(self, x, y):
        if self.pointSystem is TwoPoints._root_:
             return (x, y, 0)
        x = self.__cornerXPoint(x, y)
        if self.pointSystem is __class__._roots_[1]:
            x += self.__addititionalMove()
        y = self.__cornerYPoint(x, y, 0)
        return (x, y, 0)

    def _h1Points(self, w):
        if self.pointSystem is TwoPoints._root_:
            return self.OR if not w else self.OR - BAR[1]
        elif self.pointSystem is __class__._roots_[-2]:
            return self.OR*3 if not w else self.OR*3 - BAR[1]
        return self.OR if w else self.OR + BAR[1]

    def _pntHPolyMnr(self, x, y, z):
        if self.pointSystem is TwoPoints._root_:
            return (x, y, z)
        x = self.__cornerXPoint(x, y)
        y = self.__cornerYPoint(x, y, z)
        return (x, y, z)

    def _pntVPolyMnr(self, x, z):
        if self.pointSystem is TwoPoints._root_:
            return (x, 0, z+self.ZERO_Z)
        elif self.pointSystem is __class__._roots_[-2]:
            return (x+self.OR*2, 0, z+self.ZERO_Z)
        return (x+(self.OR - x)*2, 0, z+self.ZERO_Z)

    def __cornerXPoint(self, x, y):
        if not y:
            zero_y_x = self.__fixedZeroYXRoot(x)
            x += (self.OR - x)*2 + zero_y_x
            return x + self.__addititionalMove()
        root_x, q = self.__fixedXYRoots(x, y)
        return x + (root_x - x)*2 + self.__addititionalMove()

    def __cornerYPoint(self, x, y, z):
        root_x, root_y = self.__fixedXYRoots(x, y)
        if not y and z is self.ZERO_Z+self.OR-z:
            return root_y * 2
        elif not y:
            return 0
        return y + (root_y - y)*2

    def __addititionalMove(self):
        return self.rightHypothenuse( BAR[1] ) - BAR[1]

    @property
    def pointSystem(self):
        return self.__type_

    @pointSystem.setter
    def pointSystem(self, tp):
        assert isinstance(tp, str), "TypeError: tp (type) is str"
        assert tp in __class__._roots_, "not in %s" % __class__._roots_
        self.__type_ = tp
        return self.__type_

class ExtensionPoints(ThorusPoints):
    _root_ = str('long')

    def __init__(self, tp, l, h, *args, **kwargs):
        assert isinstance(l, float), "TypeError: l (LONG) must be float"
        assert isinstance(h, float), "TypeError: h (H1)   must be float"
        super().__init__(tp, *args, **kwargs)
        self.ZERO_Y = -l        # To measure extensions on Y carriage
        self.ZERO_Z =  h        # To lift all types of geometry
        self.__long_ = l
        self.__insertionL_,self.__insertionN_ = self.insertionUnits(l)
        self.__h1_ = h

    def extensionPoints(self, l, w):
        point1 = (self.ZERO_X, -BAR[0]/2,  self.OR + self.ZERO_Z - w)
        point2 = (self.ZERO_X, l+BAR[0]/2, self.POINTS[-1][-1][1]+self.ZERO_Z)
        return point1, point2

    def insertionUnits(self, l):
        """Retruns dimension and amount of internal orthogonal objects"""
        amount = int(l / self.isoscelesBase(self.OR-BAR[1]))
        if not amount: return 0, 0
        return l / amount, amount

    @property
    def long(self):
        return self.__long_

    @property
    def h1(self):
        return self.__h1_

    @property
    def insertionLength(self):
        return self.__insertionL_

    @property
    def insertionAmount(self):
        return self.__insertionN_

# END: Trigonometrical Common Geometry

# BEGIN: FreeCAD system covers

import FreeCAD, FreeCADGui
import Draft

class MacroRoot(object):
    def __init__(self, cup=False):
        self.CLEANUP = cup
        self.cleanUp()
        self.pl = FreeCAD.Placement()

    def vector(self, *v):
        return FreeCAD.Vector(*v)

    def recompute(self):
        self.appDoc.recompute()

    def cprint(self, message):
        App.Console.PrintMessage(message)

    def autogroup(self, obj):
        return Draft.autogroup(obj)

    def remove(self, obj):
        self.appDoc.removeObject(obj)
        self.recompute()

    def cleanUp(self):
        if not len(self.roots) or not self.CLEANUP: return
        [self.remove(obj.Name) for obj in self.roots]
        return self.cleanUp()

    def _setVisibility(self, obj, vis):
        self._getGuiObject(obj).Visibility = vis
        self.recompute()
        return obj

    def _getGuiObject(self, obj):
        return self.guiDoc.getObject(obj.Name)

    def _getFcObject(self, obj):
        return self.fcDoc.getObject(obj.Name)

    @property
    def fcDoc(self):
        return FreeCAD.ActiveDocument

    @property
    def appDoc(self):
        return App.ActiveDocument

    @property
    def guiDoc(self):
        return FreeCADGui.ActiveDocument

    @property
    def roots(self):
        return self.fcDoc.RootObjects

class BaseTools(MacroRoot):
    def Wire(self, points, vis=False, **kwargs):
        assert isinstance(points, list) and len(points), "TypeError: objs must be list"
        p = [ self.vector(*ps) for ps in points ]
        w = Draft.makeWire(p,placement=self.pl,closed=False,face=False,**kwargs)
        self.autogroup(w)
        self._setVisibility(w, vis)
        return w

    def Polygon(self, n, placement, f=True, s=None, i=True, vis=False, **kwargs):
        self.pl.Base = self.vector(*placement)
        p =  Draft.makePolygon(n,placement=self.pl,inscribed=i,face=f,support=s,**kwargs)
        self.autogroup(p)
        return self._setVisibility(p, vis)

    def Surface(self, edges, vis=False):
        assert len(edges) is 2, "AmountError: number of edges must be 2"
        edge1, edge2 = edges
        s = self.fcDoc.addObject('Part::RuledSurface', 'Surface')
        self.fcDoc.ActiveObject.Curve1=(edge1,[''])
        self.fcDoc.ActiveObject.Curve2=(edge2,[''])
        return self._setVisibility(s, vis)

    def Cut(self, base, tool, bvis=False):
        c = self.fcDoc.addObject('Part::Cut', 'Cut')
        c.Base = self._getFcObject(base)
        c.Tool = self._getFcObject(tool)
        self._setVisibility(base, bvis)
        self._setVisibility(tool, False)
        return c

    def Extrude(self, surface, direction, height, s=True, vis=True, d="Custom"):
        e = self.fcDoc.addObject('Part::Extrusion', 'Extrude')
        e.Base = surface
        e.DirMode = d
        e.Dir = self.vector(direction)
        e.LengthFwd = height
        e.Solid = True
        e.Symmetric = s
        self._setVisibility(surface, False)
        return self._setVisibility(e, vis)

    def Rotate(self, objs, A, z, a, cp=True, vis=True):
        Draft.rotate(objs,A,self.vector(*z),axis=self.vector(*a),copy=cp)
        [self._setVisibility(o, vis) for o in objs]
        return self.roots[-len(objs):] if cp else objs

    def Move(self, objs, x, y, z, cp=True, vis=True):
        Draft.move(objs, self.vector(x, y, z), copy=cp)
        [self._setVisibility(o, vis) for o in objs]
        return self.roots[-len(objs):] if cp else objs

class Model(BaseTools):
    def wire(self, points, **kwargs):
        return [self.Wire(points,**kwargs)]

    def polygon(self, sides, radius, placement, **kwargs):
        return [self.Polygon(sides, placement, radius=radius, **kwargs)]

    def cut(self, bases, tool, **kwargs):
        assert isinstance(bases, list) and len(bases), "bases must be not empty list"
        assert isinstance(tool, list) and len(tool) is 1, "one tool must be in list"
        r = []
        [ r.extend(self.__cut(base, tool, **kwargs)) for base in bases ]
        return r

    def surface(self, e1, e2, **kwargs):
        assert len(e1) is len(e2), "empty edges list"
        r = []
        [ r.extend(self.__surface([e1[i],e2[i]],**kwargs)) for i in range(len(e1)) ]
        return r

    def extrude(self, surfaces, *args, **kwargs):
        assert isinstance(surfaces, list) and len(surfaces), "bases must be not empty list"
        r = []
        [ r.extend(self.__extrude(s, *args, **kwargs)) for s in surfaces ]
        return r

    def __cut(self, base, tool, **kwargs):
        return [self.Cut(base, tool[0], **kwargs)]

    def __surface(self, edges, **kwargs):
        return [self.Surface(edges, **kwargs)]

    def __extrude(self, surface, direction, height, **kwargs):
        return [self.Extrude(surface, direction, height, **kwargs)]

class Movement(Model):
    def rotate(self, objs, angle, zero, axis, times, cp=True, **kwargs):
        assert isinstance(objs, list), "TypeError: objs must be list"
        if not len(objs): return []
        if times < 0:   # rotate backward feature
            times *= -1
            angle = -angle
        if not cp: return self.Rotate(objs, angle*times, zero, axis, cp=cp, **kwargs)
        obj = []
        for i in range(1, times+1):
            obj.extend(self.Rotate(objs, angle*i, zero, axis, cp=cp, **kwargs))
        return obj

    def move(self, objs, x, y, z, times, vis=True, **kwargs):
        assert isinstance(objs, list), "TypeError: objs must be list"
        if not len(objs): return []
        obj = []
        for i in range(1, times+1):
            xi, yi, zi = x*i, y*i, z*i
            obj.extend(self.Move(objs, xi, yi, zi, **kwargs))
        return obj

# END: FreeCAD system covers

# BEGIN: Object creation system

class Blocks(MutableMapping, ExtensionPoints):
    """

    Contains grouped dict of object roots. Created to make parametric
      design of any object divided by segments, to insert into them
          standardized constructional parts of common building

    """
    _root_types_ = ThorusPoints._roots_
    _tps_ = str('types')
    _roo_ = str('root')
    _wfr_ = str('wireframe')
    _pts_ = str('points')

    def __init__(self, *args, **kwargs):
        ExtensionPoints.__init__(self, *args, **kwargs)
        self.types = { __class__._tps_: { } }
        self._rws_ = 0
        self._cls_ = 0

    def __getitem__(self, key):
        return self.types[__class__._tps_][self._keytransform(key)]

    def __setitem__(self, key, l):
        self.__valueExtensionChecker(l)
        self.types[__class__._tps_][self._keytransform(key)] = l

    def __delitem__(self, key):
        del self.types[__class__._tps_][self._keytransform(key)]

    def __iter__(self):
        return iter(self.types[__class__._tps_])

    def __len__(self):
        return len(self.types[__class__._tps_])

    def _keytransform(self, key):
        return key

    def _getRoot(self, tp, name):
        return self.types[__class__._tps_][tp].get(name)

    def __createType(self, tp):
        self.__keyExtensionChecker( tp )
        self.types[__class__._tps_][tp] = []
        return self.types[__class__._tps_][tp]

    def append(self, tp, l):
        self.__keyExtensionChecker( tp )
        self.__valueExtensionChecker(l)
        try: self.types[__class__._tps_][tp].append(l)
        except KeyError: self.__createType(tp)
        finally: self.types[__class__._tps_][tp].append(l)

    def extend(self, name, l):
        self.__keyExtensionChecker( name )
        self.__valueExtensionChecker(l)
        try:
            self.types[__class__._tps_][name].extend(l)
        except KeyError: self.types[__class__._tps_].update({name:l})
        return self.types[__class__._tps_][name]

    def extendByFunc(self, name, func, *args):
        self.__keyExtensionChecker( name )
        return self.extend(name, func(*args))

    def extendDoubled(self, tp, name, i, l):
        assert isinstance(self[tp][name][i], list) and \
                len(self[tp][name]) < 3, \
            "TypeError: doubled types must be created before extend"
        self.__keyExtensionChecker( tp, name )
        self.__valueExtensionChecker(l)
        self.types[__class__._tps_][tp][name][i].extend(l)
        return self.types[__class__._tps_][tp][name]

    def _appendRoot(self, tp, name, l):
        self.__keyExtensionChecker( tp, name )
        self.__valueExtensionChecker(l)
        self.__rootCreator(tp, name)
        self.types[__class__._tps_][tp][name].append(l)
        return self.types[__class__._tps_][tp][name]

    def _extendRoot(self, tp, name, l):
        self.__keyExtensionChecker( tp, name )
        self.__valueExtensionChecker(l)
        self.__rootCreator(tp, name)
        self.types[__class__._tps_][tp][name].extend(l)
        return self.types[__class__._tps_][tp][name]

    def _extendRootByFunc(self, tp, name, func, *args):
        self.__keyExtensionChecker( tp, name )
        self.__rootCreator(tp, name)
        self.types[__class__._tps_][tp][name].extend(func(*args))
        return self.types[__class__._tps_][tp][name]

    def __createRootType(self, tp, name):
        assert isinstance(self.get(tp), type(None)), \
                "Given root type exists"
        self.types[__class__._tps_].update( { tp: { name: [] } } )
        return self.types[__class__._tps_][tp][name]

    def __extendRootType(self, tp, name):
        try:
            self.types[__class__._tps_][tp].update( { name: [] } )
            return self.types[__class__._tps_][tp][name]
        except KeyError: return False

    def __rootCreator(self, tp, name):
        try: self.types[__class__._tps_][tp][name]
        except KeyError: self.__extendRootType(tp, name)
        try: self.types[__class__._tps_][tp]
        except KeyError: return self.__createRootType(tp, name)

    def __keyExtensionChecker(self, *args):
        for arg in args:
            assert isinstance(arg, str), "TypeError: key is string"

    def __valueExtensionChecker(self, l):
        assert isinstance(l, list), "TypeError: types contains lists"

    @property
    def rows(self):
        return self._rws_

    @property
    def cols(self):
        return self._cls_

    @rows.setter
    def rows(self, amount):
        self._rws_ = amount
        return self._rws_

    @cols.setter
    def cols(self, amount):
        self._cls_ = amount
        return self._cls_

class WireFrame(Movement, Blocks):
    _h1_  = str('h1')
    _hpl_ = str('hPoly')
    _vpl_ = str('vPoly')
    _sht_ = str('short')
    _rof_ = str('long')

    def _createWireFrame(self, ny, w):
        self.__h1(w)
        self.__horizonPoly(ny, w)
        self.__verticalPoly(ny)
        self.__horisonLong(w, ny)
        wfr = self[Blocks._wfr_]
        assert isinstance(wfr, dict) and len(wfr), \
            "Empty wireframe dict"
        return wfr

    def __h1(self, w):
        if self.__check(self.ZERO_Z): return []
        tp = __class__._h1_ + self.pointSystem
        x = self._h1Points(w)
        self.appendWfr(tp, self.wire([
            (x, 0, 0), (x, 0, self.ZERO_Z)
            ], vis=self.wfVisibility))
        return self.getWfr(tp)

    def __horizonPoly(self, ny, w):
        tp = __class__._hpl_ + self.pointSystem
        self.appendWfr(tp, [ ] )
        hpll = len(self.getWfr(tp))-1
        self.rows = ny   # number rows
        amount = self._hPolyNumber(ny) if ny else 1
        for i in range(amount, -1, -1):
            reduc = self._reduceWidth(w or BAR[1], self.DETAIL_B*i)
            Or = self.POINTS[0][i][0]-reduc if w else self.POINTS[0][i][0]
            drop = self._dropSide(BAR[1], self.DETAIL_B*i)
            h1 = self.POINTS[0][i][1] + self.ZERO_Z
            h1 = h1 - drop if w else h1
            points = self.polyPoints(Or)[:2]
            wire = self.wire([
                self._pntHPolyMnr(x, y, h1) for x, y in points
                ], vis=self.wfVisibility)
            self.extendDoubledWfr(tp, hpll, wire)
        return self.getWfr(tp)

    def __verticalPoly(self, ny):
        tp = __class__._vpl_ + self.pointSystem
        if self.__check(ny):
            """creates empty list of vPoly frame if no rows or thorus"""
            self.extendWfr( tp, [ ] )
            return []
        self.appendWfr(tp, self.wire([
            self._pntVPolyMnr(x, z) for x, z in self.POINTS[-1][:2]
            ], vis=self.wfVisibility))
        return self.getWfr(tp)

    def __horisonLong(self, w, rows):
        if self.__check(self.ZERO_Y): return []
        tp = __class__._rof_ + self.pointSystem
        w1 = w if not w else BAR[1]
        points = self.extensionPoints(self.ZERO_Y, w1)
        self.appendWfr(tp, self.wire(
            [*points], vis=self.wfVisibility))
        return self.getWfr(tp)

    def _wirePoints(self, wire):
        """Returns FreeCAD vectorized list of wire points"""
        points = []
        for pnts in wire:
            points.append([
            self._getGuiObject(p).Object.Points for p in pnts
        ])
        return points

    def __check(self, val):
        return not val or self.pointSystem is ThorusPoints._roots_[-1]

    def _hPolyNumber(self, ny):
        expr = self.rows is self.POLY_QUARTER
        # if dome and rows == details/4
        expr0 = self.pointSystem is TwoPoints._root_ and expr
        # if thorus and rows == details/4
        expr1 = self.pointSystem is ThorusPoints._roots_[-1] and expr
        return ny-1 if expr0 or expr1 else ny

    @property
    def wfVisibility(self):
        try: return self.vis
        except AttributeError: self.wfVisibility = False
        finally: return self.vis

    @wfVisibility.setter
    def wfVisibility(self, vis):
        assert isinstance(vis, bool), "visibility is boolean property"
        self.vis = vis
        return vis

# END: Object creation system

# BEGIN: Root creation system

class RootGeom(WireFrame):
    def _reduceWidth(self, c, A):
        if not A: return c
        return self.rightCathetusB_ByA(c, A)

    def _dropSide(self, c, A):
        if not A: return 0
        return self.rightCathetusA_ByA(c, A)

class RootMovement(RootGeom):
    """Movement mechanism of machine tool"""
    def __init__(self, *args, cup=False, **kwargs):
        Blocks.__init__(self, *args, **kwargs)
        MacroRoot.__init__(self, cup=cup)
        self.dirY = 1 if self.pointSystem in ThorusPoints._roots_[1:] else -1

    def pArrayXB(self, objs, n, **kwargs):
        angle = self.DETAIL_B
        zero = (0, 0, self.ZERO_Z)
        axis = (-1, 0, 0)
        return self.rotate(objs, angle, zero, axis, n, **kwargs)

    def pArrayYB(self, objs, n, **kwargs):
        angle = self.DETAIL_B
        zero = (self.ZERO_X, 0, self.ZERO_Z)
        axis = (0, self.dirY, 0)
        return self.rotate(objs, angle, zero, axis, n, **kwargs)

    def pArrayZB(self, objs, n, **kwargs):
        angle = self.DETAIL_B
        zero = (0, 0, 0)
        axis = (0, 0, 1)
        return self.rotate(objs, angle, zero, axis, n, **kwargs)

    def longArrayZ180(self, objs, **kwargs):
        return self.rotate(objs,180,(0,self.ZERO_Y/2,0),(0,0,1),1,**kwargs)

    def squaredArray(self, objs, n, s=False, **kwargs):
        half = 0 if not self.ZERO_Y or s else self.ZERO_Y/2
        return self.rotate(objs,90,(half,-half,0),(0,0,1),n,**kwargs)

    def compoundArray(self, objs, angle, n, **kwargs):
        hypB = -90-angle/2
        x = self.rightCathetusA_ByBA(self.ZERO_Y/2, hypB)
        y = self.ZERO_Y/2
        return self.rotate(objs,angle,(x,y,0),(0,0,1),n,**kwargs)

    def rotateAndDrop(self, obj, **kwargs):
        if not len(obj): return []
        r = self.OR
        disc = self.pointSystem is ThorusPoints._roots_[-2]
        r = r if not disc else r*3
        center = (r + BAR[0]/2, 0, self.h1)
        direction = (0,self.dirY,0)
        obj = self.rotate(obj,90,center,direction,1,**kwargs)
        if self.dirY > 0:
            x = 0 if not disc else -BAR[0]
            z = -self.ZERO_Z+BAR[1]-BAR[0]/2
            z = z if not disc else z-BAR[1]
        else:
            x = -BAR[0]
            z = -self.h1+BAR[1]+BAR[0]/2
        return self.move(obj, x,0,z, 1, cp=False)

    def h1DropArray(self, obj, **kwargs):
        dim, amount = self.insertionUnits(self.ZERO_Z-BAR[1]+BAR[0]/2)
        return self.move(obj, 0,0,-dim, amount-1, **kwargs)

    def vLongArray(self, obj, n=None, **kwargs):
        dim = self.insertionLength
        amount = self.insertionAmount if n is None else n
        return self.move(obj, 0,-dim,0, amount, **kwargs)

    def hLongArray(self, obj, **kwargs):
        amount = self.insertionAmount
        return self.vLongArray(obj, n=amount-1, **kwargs)

    def _markingArray(self, wire1, wire2):
        wire1.extend(wire2)
        wire1.extend(self.squaredArray(wire2, 3, s=True))
        return self.move(wire1, 0,self.ZERO_Y,0, 1) if self.long else wire1

    def _moveBottomToZero(self, b):
        if H1: return []
        x, y, z = 0, 0, BAR[0]/2
        return self.move(b, x, y, z, 1, cp=False)

    def _shortToZero(self, ext):
        if self.h1: return ext
        return self.move(ext, 0,0,-BAR[0]/2, 1, cp=False)

    def _shortBack(self, ext):
        if self.h1: return ext
        return self._moveBottomToZero(ext)

    def _moveBtmHorBarTool(self, tool):
        if self.pointSystem is TwoPoints._root_: return tool
        elif self.pointSystem is ThorusPoints._roots_[1]:
            x = -BAR[0]
        elif self.pointSystem in ThorusPoints._roots_[-2]:
            x = BAR[0]
        elif self.pointSystem in ThorusPoints._roots_[-1]:
            x = self.ZERO_X-BAR[1]/2
        return self.move(tool, x,0,0, 1, cp=False)

    def _rotatePolygonToCut(self, obj, placement):
        return self.rotate(obj, 90, placement, (1, 0, 0), 1, cp=False)

    def _turnToExtrude(self, objs):
        o = self.__prepare(objs)
        [ o.extend(self.__turn([objs[i]], i)) for i in range(len(objs)) ]
        return o

    def _turnAfterExtrude(self, objs):
        o = self.__prepare(objs)
        [ o.extend(self.__turn([objs[i]],i,backw=True)) for i in range(len(objs)) ]
        return o

    def _alignHorisonShortBar(self, bar):
        r = self.rows
        t = r + self.POLY_QUARTER-r if r < self.POLY_QUARTER else r
        t = -t if self.pointSystem in ThorusPoints._roots_[-2:] else t
        bar = self.pArrayYB(bar, -t, cp=False)
        return bar if self.h1 else self._moveBottomToZero(bar)

    def _alignHorisonLongBar(self, bar):
        if not self.rows < self.POLY_QUARTER: return bar
        odd = self.POLY_QUARTER - self.rows
        odd = odd if not self.pointSystem is ThorusPoints._roots_[-2] else -odd
        return self.pArrayYB(bar, -odd, cp=False)

    def __prepare(self, objs):
        assert isinstance(objs, list), "TypeError: objs must be list"
        return []

    def __turn(self, obj, i, backw=False):
        """
        Torsion mechanism to give thickness to horison surfaces of Root poly.
        Revolves around Z axis by angle B/2 and Y axis by angle B.
        """
        zero_z, a_z = (0, 0, self.ZERO_Z), (0,0,1)
        zero_y, a_y = self.__zeroYAxisToTurn()
        angle = self.DETAIL_B
        n = self.__numberToTurn(self.rows - i)
        if not backw:
            obj =  self.rotate(obj, -angle/2, zero_z, a_z, 1, cp=False)
            return self.rotate(obj,  angle*n, zero_y, a_y, 1, cp=False)
        obj =  self.rotate(obj, -angle*n, zero_y, a_y, 1, cp=False)
        return self.rotate(obj,  angle/2, zero_z, a_z, 1, cp=False)

    def __numberToTurn(self, ny):
        expr = self.rows is self.POLY_QUARTER
        if self.pointSystem is TwoPoints._root_ and expr:
            return ny-1
        elif self.pointSystem is ThorusPoints._roots_[-1]:
            return ny if not expr else ny-1
        else: return ny

    def __zeroYAxisToTurn(self):
        if self.pointSystem is TwoPoints._root_:
            return (0, 0, self.ZERO_Z), (0, 1,0)
        elif self.pointSystem is ThorusPoints._roots_[1]:
            return (self.ZERO_X, 0, self.ZERO_Z), (0,-1,0)
        return (self.ZERO_X, 0, self.ZERO_Z), (0,1,0)

class RootBlocks(RootMovement):
    """Root blocks management system"""
    _drf_ = str('roof')
    _ext_ = str('extension')
    _plg_ = str('polygonal')

    def extendPlg(self, name, l):
        return self._extendRoot(__class__._plg_, name, l)

    def getPlg(self, name):
        return self._getRoot(__class__._plg_, name)

    def extendExt(self, name, l):
        return self._extendRoot(__class__._ext_, name, l)

    def getExt(self, name):
        return self._getRoot(__class__._ext_, name)

    def extendDrfByFunc(self, name, func, *args):
        self._extendRootByFunc(__class__._drf_, name, func, *args)
        return self._getRoot(__class__._drf_, name)

    def extendRootByFunc(self, name, func, *args):
        self._extendRootByFunc(Blocks._roo_, name, func, *args)
        return self._getRoot(__class__._roo_, name)

    def extendDrf(self, name, l):
        return self._extendRoot(__class__._drf_, name, l)

    def getDrf(self, name):
        return self._getRoot(__class__._drf_, name)

    def appendWfr(self, name, l):
        return self._appendRoot(Blocks._wfr_, name, l)

    def extendWfr(self, name, l):
        return self._extendRoot(Blocks._wfr_, name, l)

    def extendDoubledWfr(self, name, i, l):
        return self.extendDoubled(Blocks._wfr_, name, i, l)

    def getWfr(self, name):
        return self._getRoot(Blocks._wfr_, name)

    def extendRoot(self, name, l):
        return self._extendRoot(Blocks._roo_, name, l)

    def getRoot(self, name):
        return self._getRoot(Blocks._roo_, name)

class RootWireFrame(RootBlocks):
    _mp_  = str('marking')
    _btm_ = str('bottom')
    _sht_ = str('short')

    def _createWoodenWireFrame(self, ny, vis=False):
        assert ny < self.POLY_QUARTER + 1 and ny >= 0, \
            "check number of sigments revolving around Y axis"
        self.wfVisibility = vis
        wsW = self.rightHypothenuse(BAR[1])
        wsH = self.rightHypothenuse(BAR[0])
        for w in [0, wsW, wsH]:
            self.POINTS.append( self.polyPoints(self.OR-w) )
            if w != wsW:
                self.__bottom()
            if w == wsH: break
            self._createWireFrame(ny, w)
            self.__horisonShort(w, self.rows)
        if not self.pointSystem is ThorusPoints._roots_[-1]:
            self.__marking()
        return self.get(Blocks._wfr_)

    def __marking(self):
        zl = [0, self.ZERO_Z or BAR[0]]
        wire1 = self.wire([(0, 0, z) for z in zl], vis=True)
        self.append( __class__._mp_, wire1 )
        wire2 = self.wire([(0, 0, 0), (0, -BAR[1], 0)], vis=True)
        wires = self._markingArray(wire1, wire2)
        self.append( __class__._mp_, wires )
        return self.get( __class__._mp_ )

    def __bottom(self):
        if not H1: return []
        tp = __class__._btm_ + self.pointSystem
        p = self.POINTS[-1][:2]
        vis = self.wfVisibility
        wire = self.wire([self._pntBtmMnr(x,y) for x,y in p], vis=vis)
        return self.appendWfr(tp, wire)

    def __horisonShort(self, w, rows):
        if not self.long or not rows and not self.h1: return []
        tp = __class__._sht_ + self.pointSystem
        dim, amount = self.insertionUnits(self.ZERO_Y)
        w1 = w if not w else BAR[1]
        points = self.extensionPoints(-dim, w1)
        vis = self.wfVisibility
        wire = self.wire( [ *points ], vis=vis )
        return self.appendWfr(tp, wire)

class ModelLayer(RootWireFrame):
    def __polygonCutTool(self, height):
        placement = (self.ZERO_X, 0, self.ZERO_Z)
        p = self.polygon(DETAILS, self.OR+100, placement)
        p = self._rotatePolygonToCut(p, placement)
        return self.extrude(p, (0,1,0), height, vis=False)

    def _extrudeHPolys(self, n):
        s = []
        height = BAR[0]
        hplwf = WireFrame._hpl_ + self.pointSystem
        edges1, edges2 = self.getWfr(hplwf)
        edges1 = edges1[-n-1:]
        edges2 = edges2[-n-1:]
        tool = self.__polygonCutTool(height)
        s = self.surface(edges1, edges2)
        s = self._turnToExtrude(s)
        e = self.extrude(s, (0,0,1), height)
        extruded = self._turnAfterExtrude(e)
        return self.__cutHPolys(extruded, tool)

    def _extrudeVertical(self, edges):
        assert isinstance(edges, list) and len(edges), "empty or wrong edges list"
        edges1, edges2 = edges
        s = self.surface(edges1, edges2)
        f = self.extrude(s, (0,1,0), BAR[0])
        return f

    def _cutBtmHorBar(self, base):
        pSys = self.pointSystem
        roots = ThorusPoints._roots_
        """In Thorus or Disc mode as tool works h1 bar of Corner"""
        pSys = roots[1] if pSys is roots[3] else pSys
        h1wf = WireFrame._h1_ + pSys
        tool = self.surface(   # just the same wires as made H1 bar of
            self.getWfr(h1wf)[0],
            self.getWfr(h1wf)[1]
        )
        tool = self.extrude(tool, (0, 1, 0), BAR[0])
        tool = self._moveBtmHorBarTool(tool)
        tool2 = self.pArrayZB(tool, 1)
        prebar = self.cut( base,  tool )
        return self.cut( prebar, tool2 )

    def __cutHPolys(self, e, tool):
        s1 = self.cut(e, tool)
        s1 = self.pArrayZB(s1, -1, cp=False)
        s = self.cut(s1, tool)
        return self.pArrayZB(s, 1, cp=False)

class Root(ModelLayer):
    """Creator of root objects to build all geometry of"""
    _dome_ = ThorusPoints._roots_[0]
    _corn_ = ThorusPoints._roots_[1]
    _disc_ = ThorusPoints._roots_[2]
    _thor_ = ThorusPoints._roots_[3]
    _botm_ = RootWireFrame._btm_
    _h1ba_ = WireFrame._h1_
    _hplb_ = WireFrame._hpl_
    _vplb_ = WireFrame._vpl_
    _lnge_ = WireFrame._rof_
    _shte_ = WireFrame._sht_
    _hdrp_ = str('h1drops')

    def __init__(self, tp, *args, **kwargs):
        super().__init__(tp, *args, **kwargs)

    def wireFrame(self, ny, **kwargs):
        return self._createWoodenWireFrame(ny, **kwargs)

    def _build(self):
        wfr = self.get(Blocks._wfr_)
        assert isinstance(wfr, dict) and len(wfr), \
            "call wireFrame before build"
        self.__bottomHorizonBar()
        self.__h1WallBar()
        self.__verticalPolyBar()
        self.__horizonPolyBars(self.rows)
        self.__longHorisonBar()
        return self.get(Blocks._roo_)

    def __bottomHorizonBar(self):
        if not H1: return
        tp = __class__._botm_
        btmwf = RootWireFrame._btm_ + self.pointSystem
        s = self.surface(
            self.getWfr(btmwf)[0],
            self.getWfr(btmwf)[1]
        )
        e = self.extrude(s, (0, 0, 1), BAR[1], s=False)
        bb = self._cutBtmHorBar(e)
        self.extendRoot(tp, bb )

    def __h1WallBar(self):
        if not H1 or self.pointSystem is __class__._thor_: return
        tp = __class__._h1ba_
        h1wf = WireFrame._h1_ + self.pointSystem
        h1 = self._extrudeVertical( self.getWfr(h1wf) )
        self.extendRoot(tp, h1)

    def __horizonPolyBars(self, n):
        tp = __class__._hplb_
        bs = self._extrudeHPolys(n)
        self._moveBottomToZero([bs[-1]])
        self.extendRoot(tp, bs)

    def __verticalPolyBar(self):
        tp = __class__._vplb_
        vplwf = WireFrame._vpl_ + self.pointSystem
        if not len(self.getWfr(vplwf)): return self.extendRoot(tp, [])
        v = self._extrudeVertical( self.getWfr(vplwf) )
        self.extendRoot(tp, v)

    def __longHorisonBar(self):
        expr = self.pointSystem is __class__._thor_
        if not self.ZERO_Y or expr: return []
        tp = __class__._lnge_
        rofwf = WireFrame._rof_ + self.pointSystem
        s = self.surface(
            self.getWfr(rofwf)[0],
            self.getWfr(rofwf)[1])
        b = self.extrude(s, (1,0,0), BAR[0])
        b = self._alignHorisonLongBar(b)
        self.extendRoot(tp, b)
        self.__shortHorisonBar()

    def __shortHorisonBar(self):
        tp = __class__._shte_
        shtwf = WireFrame._sht_ + self.pointSystem
        if not self.rows and not self.h1: return []
        elif not len(self.getWfr(shtwf)): return []
        s = self.surface(
            self.getWfr(shtwf)[0],
            self.getWfr(shtwf)[1])
        b = self.extrude(s, (1,0,0), BAR[0])
        b = self._alignHorisonShortBar(b)
        self.extendRoot(tp, b)

class DomeRoot(Root):
    def __init__(self, *args, **kwargs):
        super().__init__(Root._dome_, *args, **kwargs)

    def root(self):
        self._build()

class CornerRoot(Root):
    def __init__(self, *args, **kwargs):
        super().__init__(Root._corn_, *args, **kwargs)

    def root(self):
        return self._build()

class DiscRoot(Root):
    def __init__(self, *args, **kwargs):
        super().__init__(Root._disc_, *args, **kwargs)

    def root(self):
        return self._build()

class ThorusRoot(Root):
    def __init__(self, *args, tp=None, **kwargs):
        tp = tp if isinstance(tp, str) else Root._thor_
        assert tp in ThorusPoints._roots_[1:], "ThorusTypeError: wrong type"
        super().__init__(tp, *args, **kwargs)

    def wireFrame(self, ny, **kwargs):
        self._cornWireFrame(ny, **kwargs)
        self.__thorWireFrame(ny, **kwargs)
        return self.get(Blocks._wfr_)

    def root(self):
        self._cornRoot()
        self.__thorRoot()
        return self.get(Blocks._roo_)

    def _wireFrame(self, ny, **kwargs):
        return self._createWoodenWireFrame(ny, **kwargs)

    def _cornWireFrame(self, ny, **kwargs):
        self.pointSystem = Root._corn_
        return self._wireFrame(ny, **kwargs)

    def _cornRoot(self):
        self.pointSystem = Root._corn_
        return self._build()

    def __thorWireFrame(self, ny, **kwargs):
        self.pointSystem = Root._thor_
        return self._wireFrame(ny, **kwargs)

    def __thorRoot(self):
        self.pointSystem = Root._thor_
        return self._build()

class MonoDomeRoot():    pass
class MonoCornerRoot():  pass
class WheelRoot():       pass

# END: Root creation system

# BEGIN: Basic flexible extends and compound

class Extend(object):
    """
    Root objects extend tool and over layer of movement
    system, which works just with given objects
    """
    _dome_ = Root._dome_
    _corn_ = Root._corn_
    _disc_ = Root._disc_
    _thor_ = Root._thor_
    _vert_ = str('vertical')
    _hori_ = str('horison')
    _allp_ = str('allpoly')
    _alle_ = str('allext')
    _roof_ = str('roof')

    def __init__(self, obj, cols):
        assert isinstance(obj, Root), "obj must be one of Root objects"
        assert isinstance(cols, int) and cols>0 and cols<obj.DETAILS+1, \
            "COLS not in range"
        assert obj.pointSystem in [
            __class__._dome_,__class__._corn_,
            __class__._disc_,__class__._thor_], "Unknown compound type"
        self.__rows_ = obj.rows
        self.__cols_ = cols
        obj.cols = cols
        self.obj = obj
        self.__long_ = obj.long
        self.__h1_ = obj.h1
        self.__completePartial(obj)
        self.__revolveHPolygonalZ(obj, cols-1)
        self.__extensionCompound(obj)
        self.__collectAllExt(obj)

    def __completePartial(self, obj):
        """vPoly array, drops to h1, bottoms, long array"""
        self.__moveH1ToThor(obj)
        self.__dropHPolyToH1(obj)
        self.__collectHorisons(obj)
        self.__revolveVPolygonalY(obj, self.rows-1)

    def __revolveHPolygonalZ(self, obj, n):
        name = __class__._allp_
        allp = obj.getPlg(__class__._vert_).copy()
        allp.extend(obj.getPlg(__class__._hori_).copy())
        obj.extendPlg(name, allp.copy())
        obj.extendPlg(name, obj.pArrayZB(allp,n).copy())

    def __extensionCompound(self, obj):
        self.__dropShortExt(obj)
        self.__dropAndPutBottomExt(obj)
        self.__revolveShortPolygonalY(obj)
        self.__addThoroidalLong(obj)
        self.__verticalsLongArray(obj)
        self.__horisonsLongArray(obj)

    def __moveH1ToThor(self, obj):
        if not self.h1: return
        name = __class__._vert_
        h1 = obj.getRoot(Root._h1ba_).copy()
        expr = obj.pointSystem is __class__._thor_
        if expr:
            args = (RootBlocks._plg_, name, h1)
            h1 = (self.__moveBarToThor(*args))
        else:
            obj.extendPlg(name, h1)

    def __dropHPolyToH1(self, obj):
        if not self.h1: return
        hPs = obj.getRoot(Root._hplb_).copy()
        name = __class__._hori_
        expr = obj.pointSystem is __class__._thor_
        hP = [hPs[-1], hPs[self.rows]] if expr else [hPs[-1]]
        obj.extendRoot(Root._hdrp_, obj.h1DropArray(hP))

    def __collectHorisons(self, obj):
        name = __class__._hori_
        for hp in [Root._hdrp_,Root._hplb_,Root._botm_]:
            try: obj.extendPlg(name, obj.getRoot(hp).copy())
            except AttributeError: continue

    def __revolveVPolygonalY(self, obj, n):
        vP = obj.getRoot(Root._vplb_).copy()
        if not len(vP): return []
        name = __class__._vert_
        n = n if not obj.pointSystem is __class__._disc_ else -n
        func = obj.extendRootByFunc
        vP.extend(obj.pArrayYB(vP,n))
        if obj.pointSystem is __class__._thor_:
            a = 90 + (obj.POLY_QUARTER - self.rows) * obj.DETAIL_B
            center = (obj.ZERO_X, 0, obj.ZERO_Z)
            vP.extend(obj.rotate(vP, a, center, (0,1,0), 1))
        obj.extendPlg(name, vP)

    def __dropShortExt(self, obj):
        if not self.long: return
        try: ext = obj.getRoot(Root._shte_).copy()
        except AttributeError: ext = obj.getRoot(Root._lnge_).copy()
        name = __class__._hori_
        drp = False
        if self.h1:
            drp = obj.h1DropArray(ext)
            obj.extendExt(name, drp)
        if obj.pointSystem is __class__._thor_ and drp:
            tp = RootBlocks._ext_
            self.__moveBarToThor(tp, name, drp)

    def __dropAndPutBottomExt(self, obj):
        if not self.long or not self.h1: return
        ext = obj.getRoot(Root._shte_)
        cp = False if not self.rows else True
        put = obj.rotateAndDrop(ext, cp=cp)
        args = (RootBlocks._ext_, __class__._hori_, put)
        obj._extendRoot(*args)
        if obj.pointSystem is __class__._thor_:
            self.__moveBarToThor(*args, add=BAR[1]-BAR[0])

    def __revolveShortPolygonalY(self, obj):
        if not self.rows or not self.long: return
        name = __class__._hori_
        rows = self.rows
        ext = obj.getRoot(Root._shte_).copy()
        ext = obj._shortToZero(ext)
        if obj.pointSystem in [__class__._dome_,__class__._corn_]:
            ext.extend(obj.pArrayYB(ext, rows-1))
        elif obj.pointSystem is __class__._disc_:
            ext.extend(obj.pArrayYB(ext, -rows+1))
        else:
            odd = obj.POLY_QUARTER - rows + 1
            number = rows-1
            angle = obj.DETAIL_B
            center = (obj.OR*2,0,obj.ZERO_Z)
            ext.extend(obj.rotate(ext, angle, center, (0,1,0), number))
            ext.extend(obj.rotate(ext, 90+angle*odd, center, (0,1,0), 1))
            obj._shortBack([ext[-1]])
        obj.extendExt(name, ext)
        obj._shortBack([obj.getExt(name)[0]])

    def __addThoroidalLong(self, obj):
        if not self.long: return
        roof = obj.getRoot(Root._lnge_).copy()
        name = __class__._roof_
        obj.extendExt(name, roof)
        if not obj.pointSystem is __class__._thor_: return
        rows = self.rows
        if rows is obj.POLY_QUARTER: return
        elif not rows:
            args = (RootBlocks._ext_,name,roof)
            return self.__moveBarToThor(*args)
        odd = (obj.POLY_QUARTER - rows)*2
        angle = obj.DETAIL_B*odd
        center = (obj.OR*2, 0, obj.ZERO_Z)
        roof = obj.rotate(roof, angle, center, (0,1,0), 1)
        obj.extendExt(name, roof)

    def __verticalsLongArray(self, obj):
        if not self.long or self.__emptyVerticals(): return
        name = __class__._vert_
        bars = obj.getPlg(name).copy()
        obj.extendExt(name, obj.vLongArray(bars))

    def __horisonsLongArray(self, obj):
        if not self.long or self.__emptyVerticals(): return
        name = __class__._hori_
        bars = obj.getExt(name).copy()
        obj.extendExt(name, obj.hLongArray(bars))

    def __moveBarToThor(self, tp, name, bar, add=0):
        args = (bar, obj.OR*2-BAR[1]+add, 0, 0, 1)
        bar.extend(obj.move(*args))
        obj._extendRoot(tp, name, bar)
        return bar

    def __getRoof(self, obj):
        roof = obj.getRoot(Root._lnge_).copy()
        expr = obj.pointSystem in ThorusPoints._roots_[1:]
        if self.rows < obj.POLY_QUARTER or expr:
            return roof
        return []

    def __uniteExt(self, btm, drp):
        btm.extend(drp.copy())
        return btm

    def __collectAllExt(self, obj):
        if not self.long: return
        for n in [__class__._vert_,__class__._hori_,__class__._roof_]:
            obj.extendExt(__class__._alle_, obj.getExt(n).copy())

    def __emptyVerticals(self):
        return not self.rows and not self.h1

    def rotate(self, objs, angle, center, axis, copy):
        return self.obj.rotate(objs, angle, center, axis, 1, cp=copy)

    def move(self, objs, x,y,z, copy):
        return self.obj.move(objs, x,y,z, 1, cp=copy)

    @property
    def rows(self):
        return self.__rows_

    @property
    def cols(self):
        return self.__cols_

    @property
    def long(self):
        return self.__long_

    @property
    def h1(self):
        return self.__h1_

class Compound(Extend):
    """Extended array, mirroring and movement system for stricts:"""
    _allp_ = Extend._allp_
    _alle_ = Extend._alle_
    _totl_ = str('total')

    def __init__(self, obj, cols, *args, **kwargs):
        hd = obj.DETAILS/2
        cols = hd if cols > hd and obj.long else cols
        super().__init__(obj, int(cols))
        self.__collectTotal(obj)

    def compound(self):
        obj = self.obj
        name = __class__._totl_
        total = obj.get(name)
        times = obj.CIRCLE / (self.cols*obj.DETAIL_B)
        angle = obj.CIRCLE / times
        obj.extend(name, obj.compoundArray(total, angle, int(times-1)))
        return obj.get(name)

    def __collectTotal(self, obj):
        name = __class__._totl_
        obj.extend(name, obj.getPlg(__class__._allp_).copy())
        try:
            obj.extend(name, obj.getExt(__class__._alle_).copy())
        except KeyError: pass
        return obj.get(name)

    def rotate(self, angle, center, axis, copy):
        objs = self.obj.get(__class__._totl_)
        return super().rotate(objs, angle, center, axis, copy)

    def move(self, vector, copy):
        objs = self.obj.get(__class__._totl_)
        x,y,z = vector
        return super().move(objs, x,y,z, copy)

class Dome(Compound):
    def __init__(self, obj, nz, *args, **kwargs):
        super().__init__(obj, nz, *args, **kwargs)

class Corner(Compound):
    def __init__(self, obj, nz, *args, **kwargs):
        super().__init__(obj, nz, *args, **kwargs)

class Disc (Compound):
    def __init__(self, obj, nz, *args, **kwargs):
        super().__init__(obj, nz, *args, **kwargs)

class Thorus(Compound):
    def __init__(self, obj, nz, *args, **kwargs):
        super().__init__(obj, nz, *args, **kwargs)

class Mono (Compound): pass
class Wheel(Compound): pass

# END: Basic flexible extends and compound

# BEGIN: Coding

###################################################################################
#
#                               [ coding ]:
#
###################################################################################

def buildObject(OBJ, obj, s, root, COLS, EXTEND, COMPOUND, ROTATE, MOVE ):
    if not OBJ is str(s): return []
    o = None
    if EXTEND:
        o = root(obj, COLS)
    if COMPOUND:
        o.compound()
    if ROTATE.get('DO'):                # at first rotate
        angle = ROTATE.get('ANGLE')
        center = ROTATE.get('CENTER')
        axis = ROTATE.get('AXIS')
        copy = ROTATE.get('COPY')
        o.rotate(angle, center, axis, copy)
    if MOVE.get('DO'):                  # next move
        vector = MOVE.get('VECTOR')
        cp = MOVE.get('COPY')
        o.move(vector, cp)
    return o

if __name__ == "__main__":

    args = (LONG, H1, OR, DETAILS)

    if       THORUS.get('CORNER') and not THORUS.get('DISC'):
          obj = CornerRoot(*args, cup=CLEANUP)
          OBJ = str('CORNER')

    elif not THORUS.get('CORNER') and     THORUS.get('DISC'):
          obj = DiscRoot  (*args, cup=CLEANUP)
          OBJ = str('DISC')

    elif     THORUS.get('CORNER') and     THORUS.get('DISC'):
          obj = ThorusRoot(*args, cup=CLEANUP)
          OBJ = str('THORUS')

    else:
          obj = DomeRoot  (*args, cup=CLEANUP)
          OBJ = str('DOME')

    obj.wireFrame(ROWS, vis=WIREFRAME)
    if not ROOT: exit(1)

    obj.root()

    o = buildObject( OBJ, obj, 'DOME',   Dome,   COLS, EXTEND, COMPOUND, ROTATE, MOVE )
    o = buildObject( OBJ, obj, 'CORNER', Corner, COLS, EXTEND, COMPOUND, ROTATE, MOVE )
    o = buildObject( OBJ, obj, 'DISC',   Disc,   COLS, EXTEND, COMPOUND, ROTATE, MOVE )
    o = buildObject( OBJ, obj, 'THORUS', Thorus, COLS, EXTEND, COMPOUND, ROTATE, MOVE )

